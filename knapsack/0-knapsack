#!/usr/bin/python3

def greedy_fractional(items, max_weight):
    total_value = 0
    total_weight = 0
    for value_density, weight, value in sorted_items:
        if total_weight + weight <= max_weight:
            # Take the whole item
            total_value += value
            total_weight += weight
        else:
            # Take the fraction of the item that fits
            can_take_weight = max_weight - total_weight
            total_value += value_density * can_take_weight
            break # Knapsack is full
    return total_value

def greedy_0_1(items, max_weight):
    total_value = 0
    total_weight = 0
    for value_density, weight, value in sorted_items:
        if total_weight + weight <= max_weight:
            # Take the whole item
            total_value += value
            total_weight += weight
    return total_value

def knapsack_0_1(items, max_weight):
    dp_table = [[0 for _ in range(max_weight + 1)] for _ in range(len(items) + 1)]
    for i in range(1, len(items) + 1):
        for w in range(1, max_weight + 1):
            item_weight = items[i-1][0]
            item_value = items[i-1][1]
            if item_weight > w:
                dp_table[i][w] = dp_table[i-1][w]
            else:
                dp_table[i][w] = max(dp_table[i-1][w], dp_table[i-1][w - item_weight] + item_value)
    return dp_table[-1][-1]

# Items and weights
items = [(5, 30), (10, 20), (20, 100), (30, 90), (40, 160)]
value_per_weight = [(value/weight, weight, value) for weight, value in items]
sorted_items = sorted(value_per_weight, reverse=True)  # Sorted based on value density
max_weight = 60  # Maximum weight the knapsack can hold

# Calculate the greedy and optimal solutions
fractional_greedy_value = greedy_fractional(sorted_items, max_weight)
zero_one_greedy_value = greedy_0_1(sorted_items, max_weight)
optimal_0_1_value = knapsack_0_1(items, max_weight)

# Output the results
print(f"Greedy fractional value: {fractional_greedy_value}")
print(f"Greedy 0-1 value: {zero_one_greedy_value}")
print(f"Optimal 0-1 value: {optimal_0_1_value}")
